   # Alignment of each PPM range
   if (algo=='clupa') {
   
      BLCOEFF <- 10
      SNR.Th <- 5
      scales <- seq(1, 16, 2)
      SHIFTCOEF <- procParams$RELDECAL
      refInd <- procParams$IDXSREF

      library(speaq)

      i1 <- ifelse( max(zoneref)>=specMat$ppm_max, 1, length(which(specMat$ppm>max(zoneref))) )
      i2 <- ifelse( min(zoneref)<=specMat$ppm_min, specMat$size - 1, which(specMat$ppm<=min(zoneref))[1] )
      n <- i2-i1+1
      X <- specMat$int[ , c(i1:i2)]
      specSig <- fitdistr(specMat$int[ ,length(which(specMat$ppm>PPM_NOISE_AREA[2])):(which(specMat$ppm<=PPM_NOISE_AREA[1])[1])], "normal")            
      baselineThresh <- BLCOEFF*specSig$estimate[2]
      maxShift <- round(n*SHIFTCOEF)

      #peakList <- detectSpecPeaks(X, nDivRange=128, scales=scales, baselineThresh=baselineThresh, SNR.Th=SNR.Th, verbose=F)
      peakList = NULL
      for (i in 1:nrow(X)) {
           myPeakRes = NULL
           peakInfo <- peakDetectionCWT(X[i,],scales=scales, SNR.Th=SNR.Th)
           majorPeakInfo = peakInfo$majorPeakInfo
           if (length(majorPeakInfo$peakIndex) > 0){
               myPeakRes <- majorPeakInfo$peakIndex
           }
           peakList[i] <- list(myPeakRes)
           peakList[[i]] <- peakList[[i]][which(X[i,peakList[[i]]] > baselineThresh)]
           # unique and sort
           peakList[[i]] <- sort(unique(peakList[[i]]));
           Write.LOG(LOGFILE,paste("Ralign1D:  Spectrum",samples[i,2],"has", length(peakList[[i]]), "peaks"));
      }


      if (refInd==0) {
         resFindRef <- findRef(peakList)
         refInd <- resFindRef$refInd
      }

      Write.LOG(LOGFILE,paste("Ralign1D:  Reference spectrum = ",samples[refInd,2]));
      Write.LOG(LOGFILE,paste("Ralign1D:  Max Shift = ",maxShift*specMat$dppm," ppm (",maxShift,")"));
      
      Y <- dohCluster(X, peakList, refInd=refInd, maxShift=maxShift, acceptLostPeak=T, verbose=F)
      specMat$int[ , c(i1:i2)] <- Y

   }

